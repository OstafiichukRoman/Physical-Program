import streamlit as st
import numpy as np

with st.container(border=True):
    st.title("üî¨ –ö–∞–ª—å–∫—É–ª—è—Ç–æ—Ä–∏ —Ä–µ–Ω—Ç–≥–µ–Ω—ñ–≤—Å—å–∫–æ—ó –¥–∏—Ñ—Ä–∞–∫—Ü—ñ—ó")
    st.write("–†–æ–∑—Ä–∞—Ö—É–Ω–æ–∫ –ø–∞—Ä–∞–º–µ—Ç—Ä—ñ–≤ –¥–∏—Ñ—Ä–∞–∫—Ü—ñ—ó —Ç–∞ –∫—Ä–∏—Å—Ç–∞–ª—ñ—á–Ω–æ—ó “ë—Ä–∞—Ç–∫–∏.")
    
    # --- –°—Ç–≤–æ—Ä—é—î–º–æ –¥–≤—ñ –≤–∫–ª–∞–¥–∫–∏ ---
    tab1, tab2 = st.tabs(["–ó–∞–∫–æ–Ω –ë—Ä–µ–≥–≥–∞", "–Ü–Ω–¥–µ–∫—Å–∏ –ú—ñ–ª–ª–µ—Ä–∞ (–¥–ª—è –∫—É–±. “ë—Ä–∞—Ç–æ–∫)"])

    # --- –í–∫–ª–∞–¥–∫–∞ 1: –ó–∞–∫–æ–Ω –ë—Ä–µ–≥–≥–∞ ---
    with tab1:
        st.header("–ó–∞–∫–æ–Ω –í—É–ª—å—Ñ–∞-–ë—Ä–µ–≥–≥–∞")
        
        # --- –ë–õ–û–ö –¢–ï–û–†–Ü–á ---
        with st.expander("üìñ –í—ñ–¥–∫—Ä–∏—Ç–∏ —Ç–µ–æ—Ä—ñ—é —Ç–∞ —Ñ–æ—Ä–º—É–ª–∏", expanded=False):
            st.write("–ó–∞–∫–æ–Ω –ë—Ä–µ–≥–≥–∞ –æ–ø–∏—Å—É—î —É–º–æ–≤—É –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–∏–≤–Ω–æ—ó —ñ–Ω—Ç–µ—Ä—Ñ–µ—Ä–µ–Ω—Ü—ñ—ó (–¥–∏—Ñ—Ä–∞–∫—Ü—ñ–π–Ω–æ–≥–æ –º–∞–∫—Å–∏–º—É–º—É) –¥–ª—è —Ä–µ–Ω—Ç–≥–µ–Ω—ñ–≤—Å—å–∫–∏—Ö –ø—Ä–æ–º–µ–Ω—ñ–≤, –≤—ñ–¥–±–∏—Ç–∏—Ö –≤—ñ–¥ –ø–∞—Ä–∞–ª–µ–ª—å–Ω–∏—Ö –∫—Ä–∏—Å—Ç–∞–ª—ñ—á–Ω–∏—Ö –ø–ª–æ—â–∏–Ω, —Ä–æ–∑–¥—ñ–ª–µ–Ω–∏—Ö –≤—ñ–¥—Å—Ç–∞–Ω–Ω—é $d$.")
            st.latex(r"n\lambda = 2d \sin(\theta)")
            st.markdown("""
            * $n$ ‚Äî –ø–æ—Ä—è–¥–æ–∫ –¥–∏—Ñ—Ä–∞–∫—Ü—ñ—ó (—Ü—ñ–ª–µ —á–∏—Å–ª–æ $1, 2, 3...$)
            * $\lambda$ ‚Äî –¥–æ–≤–∂–∏–Ω–∞ —Ö–≤–∏–ª—ñ —Ä–µ–Ω—Ç–≥–µ–Ω—ñ–≤—Å—å–∫–æ–≥–æ –≤–∏–ø—Ä–æ–º—ñ–Ω—é–≤–∞–Ω–Ω—è
            * $d$ ‚Äî –º—ñ–∂–ø–ª–æ—â–∏–Ω–Ω–∞ –≤—ñ–¥—Å—Ç–∞–Ω—å
            * $\theta$ ‚Äî –∫—É—Ç –ë—Ä–µ–≥–≥–∞ (–∫—É—Ç –∫–æ–≤–∑–∞–Ω–Ω—è)
            """)
        
        st.subheader("–©–æ —Ä–æ–∑—Ä–∞—Ö—É–≤–∞—Ç–∏?")
        calc_option = st.radio(
            "–û–±–µ—Ä—ñ—Ç—å –Ω–µ–≤—ñ–¥–æ–º—É –≤–µ–ª–∏—á–∏–Ω—É:",
            ('–ö—É—Ç (Œ∏)', '–î–æ–≤–∂–∏–Ω–∞ —Ö–≤–∏–ª—ñ (Œª)', '–ú—ñ–∂–ø–ª–æ—â–∏–Ω–Ω–∞ –≤—ñ–¥—Å—Ç–∞–Ω—å (d)'), 
            horizontal=True,
            key="bragg_radio"
        )
        st.divider()
        
        if calc_option == '–ö—É—Ç (Œ∏)':
            n = st.number_input("–ü–æ—Ä—è–¥–æ–∫ –¥–∏—Ñ—Ä–∞–∫—Ü—ñ—ó (n)", min_value=1, value=1, step=1, key="bragg_n1")
            lam = st.number_input("–î–æ–≤–∂–∏–Ω–∞ —Ö–≤–∏–ª—ñ (Œª), √Ö (–ê–Ω–≥—Å—Ç—Ä–µ–º)", min_value=0.1, value=1.54, key="bragg_l1")
            d = st.number_input("–ú—ñ–∂–ø–ª–æ—â–∏–Ω–Ω–∞ –≤—ñ–¥—Å—Ç–∞–Ω—å (d), √Ö", min_value=0.1, value=3.0, key="bragg_d1")
            
            # –û–±—á–∏—Å–ª–µ–Ω–Ω—è –∫—É—Ç–∞
            if d <= 0:
                st.error("d (–≤—ñ–¥—Å—Ç–∞–Ω—å) –ø–æ–≤–∏–Ω–Ω–∞ –±—É—Ç–∏ –¥–æ–¥–∞—Ç–Ω–æ—é.")
            else:
                sin_theta = (n * lam) / (2 * d)
                if abs(sin_theta) > 1:
                    st.error("–î–∏—Ñ—Ä–∞–∫—Ü—ñ—è –Ω–µ–º–æ–∂–ª–∏–≤–∞ (sin(Œ∏) > 1). –ó–º—ñ–Ω—ñ—Ç—å –ø–∞—Ä–∞–º–µ—Ç—Ä–∏.")
                else:
                    theta_rad = np.arcsin(sin_theta)
                    theta_deg = np.rad2deg(theta_rad)
                    st.metric("–ö—É—Ç –ë—Ä–µ–≥–≥–∞ (Œ∏)", f"{theta_deg:.3f}¬∞")
            
        elif calc_option == '–î–æ–≤–∂–∏–Ω–∞ —Ö–≤–∏–ª—ñ (Œª)':
            n = st.number_input("–ü–æ—Ä—è–¥–æ–∫ –¥–∏—Ñ—Ä–∞–∫—Ü—ñ—ó (n)", min_value=1, value=1, step=1, key="bragg_n2")
            d = st.number_input("–ú—ñ–∂–ø–ª–æ—â–∏–Ω–Ω–∞ –≤—ñ–¥—Å—Ç–∞–Ω—å (d), √Ö", min_value=0.1, value=3.0, key="bragg_d2")
            theta_deg = st.number_input("–ö—É—Ç –ë—Ä–µ–≥–≥–∞ (Œ∏), –≥—Ä–∞–¥—É—Å–∏", min_value=0.0, max_value=90.0, value=15.0, key="bragg_t2")
            
            # –û–±—á–∏—Å–ª–µ–Ω–Ω—è –¥–æ–≤–∂–∏–Ω–∏ —Ö–≤–∏–ª—ñ
            theta_rad = np.deg2rad(theta_deg)
            lam = (2 * d * np.sin(theta_rad)) / n
            st.metric("–î–æ–≤–∂–∏–Ω–∞ —Ö–≤–∏–ª—ñ (Œª)", f"{lam:.4f} √Ö")
            
        elif calc_option == '–ú—ñ–∂–ø–ª–æ—â–∏–Ω–Ω–∞ –≤—ñ–¥—Å—Ç–∞–Ω—å (d)':
            n = st.number_input("–ü–æ—Ä—è–¥–æ–∫ –¥–∏—Ñ—Ä–∞–∫—Ü—ñ—ó (n)", min_value=1, value=1, step=1, key="bragg_n3")
            lam = st.number_input("–î–æ–≤–∂–∏–Ω–∞ —Ö–≤–∏–ª—ñ (Œª), √Ö", min_value=0.1, value=1.54, key="bragg_l3")
            theta_deg = st.number_input("–ö—É—Ç –ë—Ä–µ–≥–≥–∞ (Œ∏), –≥—Ä–∞–¥—É—Å–∏", min_value=0.0, max_value=90.0, value=15.0, key="bragg_t3")

            # –û–±—á–∏—Å–ª–µ–Ω–Ω—è –º—ñ–∂–ø–ª–æ—â–∏–Ω–Ω–æ—ó –≤—ñ–¥—Å—Ç–∞–Ω—ñ
            theta_rad = np.deg2rad(theta_deg)
            sin_theta = np.sin(theta_rad)
            
            if sin_theta <= 0:
                st.error("–ö—É—Ç (Œ∏) –º–∞—î –±—É—Ç–∏ –±—ñ–ª—å—à–∏–º –∑–∞ 0 –¥–ª—è –Ω–µ–Ω—É–ª—å–æ–≤–æ—ó –≤—ñ–¥—Å—Ç–∞–Ω—ñ d.")
            elif n * lam == 0:
                st.error("–ü–æ—Ä—è–¥–æ–∫ (n) —ñ –¥–æ–≤–∂–∏–Ω–∞ —Ö–≤–∏–ª—ñ (Œª) –º–∞—é—Ç—å –±—É—Ç–∏ –Ω–µ–Ω—É–ª—å–æ–≤–∏–º–∏.")
            else:
                d = (n * lam) / (2 * sin_theta)
                st.metric("–ú—ñ–∂–ø–ª–æ—â–∏–Ω–Ω–∞ –≤—ñ–¥—Å—Ç–∞–Ω—å (d)", f"{d:.4f} √Ö")

    # --- –í–∫–ª–∞–¥–∫–∞ 2: –Ü–Ω–¥–µ–∫—Å–∏ –ú—ñ–ª–ª–µ—Ä–∞ ---
    with tab2:
        st.header("–Ü–Ω–¥–µ–∫—Å–∏ –ú—ñ–ª–ª–µ—Ä–∞ —Ç–∞ –≤—ñ–¥—Å—Ç–∞–Ω—å (d_hkl)")
        
        # --- –ë–õ–û–ö –¢–ï–û–†–Ü–á ---
        with st.expander("üìñ –í—ñ–¥–∫—Ä–∏—Ç–∏ —Ç–µ–æ—Ä—ñ—é —Ç–∞ —Ñ–æ—Ä–º—É–ª–∏", expanded=False):
            st.subheader("–Ü–Ω–¥–µ–∫—Å–∏ –ú—ñ–ª–ª–µ—Ä–∞ (hkl)")
            st.write("–¶–µ –Ω–∞–±—ñ—Ä –∑ —Ç—Ä—å–æ—Ö —Ü—ñ–ª–∏—Ö —á–∏—Å–µ–ª $(h, k, l)$, —è–∫–∏–π –æ–¥–Ω–æ–∑–Ω–∞—á–Ω–æ –≤–∏–∑–Ω–∞—á–∞—î –æ—Ä—ñ—î–Ω—Ç–∞—Ü—ñ—é –∫—Ä–∏—Å—Ç–∞–ª–æ–≥—Ä–∞—Ñ—ñ—á–Ω–æ—ó –ø–ª–æ—â–∏–Ω–∏.")
            st.write("**–Ø–∫ –∑–Ω–∞–π—Ç–∏:**")
            st.markdown("""
            1. –ó–Ω–∞–π—Ç–∏ –ø–µ—Ä–µ—Ç–∏–Ω–∏ –ø–ª–æ—â–∏–Ω–∏ –∑ –æ—Å—è–º–∏ $a, b, c$ (–Ω–∞–ø—Ä., $1a, 2b, \infty c$).
            2. –í–∑—è—Ç–∏ –æ–±–µ—Ä–Ω–µ–Ω—ñ —á–∏—Å–ª–∞: $(1/1, 1/2, 1/\infty) \to (1, 0.5, 0)$.
            3. –ó–≤–µ—Å—Ç–∏ –¥–æ –Ω–∞–π–º–µ–Ω—à–∏—Ö —Ü—ñ–ª–∏—Ö —á–∏—Å–µ–ª (–ø–æ–º–Ω–æ–∂–∏—Ç–∏ –Ω–∞ —Å–ø—ñ–ª—å–Ω–∏–π –∑–Ω–∞–º–µ–Ω–Ω–∏–∫): $\to (2, 1, 0)$.
            4. –Ü–Ω–¥–µ–∫—Å–∏ —Ü—ñ—î—ó –ø–ª–æ—â–∏–Ω–∏: $(210)$.
            """)
            st.subheader("–ú—ñ–∂–ø–ª–æ—â–∏–Ω–Ω–∞ –≤—ñ–¥—Å—Ç–∞–Ω—å –¥–ª—è –∫—É–±—ñ—á–Ω–∏—Ö “ë—Ä–∞—Ç–æ–∫")
            st.write("–í—ñ–¥—Å—Ç–∞–Ω—å $d_{hkl}$ –º—ñ–∂ –ø–∞—Ä–∞–ª–µ–ª—å–Ω–∏–º–∏ –ø–ª–æ—â–∏–Ω–∞–º–∏ $(hkl)$ —Ç–∞ –ø–æ—á–∞—Ç–∫–æ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç:")
            st.latex(r"d_{hkl} = \frac{a}{\sqrt{h^2 + k^2 + l^2}}")
            st.write("* $a$ ‚Äî –ø–∞—Ä–∞–º–µ—Ç—Ä “ë—Ä–∞—Ç–∫–∏")

        st.subheader("–ö–∞–ª—å–∫—É–ª—è—Ç–æ—Ä d_hkl")
        a = st.number_input("–ü–∞—Ä–∞–º–µ—Ç—Ä “ë—Ä–∞—Ç–∫–∏ (a), √Ö", min_value=0.1, value=4.0, key="miller_a")
        
        col_h, col_k, col_l = st.columns(3)
        h = col_h.number_input("h", min_value=0, value=1, step=1, key="miller_h")
        k = col_k.number_input("k", min_value=0, value=1, step=1, key="miller_k")
        l = col_l.number_input("l", min_value=0, value=0, step=1, key="miller_l")
        
        # –û–±—á–∏—Å–ª–µ–Ω–Ω—è d_hkl
        denominator = np.sqrt(h**2 + k**2 + l**2)
        if denominator == 0:
            st.error("–Ü–Ω–¥–µ–∫—Å–∏ (0, 0, 0) –Ω–µ –≤–∏–∑–Ω–∞—á–∞—é—Ç—å –ø–ª–æ—â–∏–Ω—É.")
        else:
            d_hkl = a / denominator
            st.metric(f"–í—ñ–¥—Å—Ç–∞–Ω—å d_({h}{k}{l})", f"{d_hkl:.4f} √Ö")
            
        st.divider()
        
        st.subheader("–ö–∞–ª—å–∫—É–ª—è—Ç–æ—Ä —ñ–Ω–¥–µ–∫—Å—ñ–≤ –ú—ñ–ª–ª–µ—Ä–∞")
        st.write("–ó–Ω–∞—Ö–æ–¥–∏—Ç—å (hkl) –∑–∞ –ø–µ—Ä–µ—Ç–∏–Ω–∞–º–∏ –∑ –æ—Å—è–º–∏. –í–≤–µ–¥—ñ—Ç—å 'inf' –¥–ª—è –Ω–µ—Å–∫—ñ–Ω—á–µ–Ω–Ω–æ—Å—Ç—ñ.")
        col1, col2, col3 = st.columns(3)
        int_a_str = col1.text_input("–ü–µ—Ä–µ—Ç–∏–Ω –ø–æ 'a'", value="1.0", key="miller_inta")
        int_b_str = col2.text_input("–ü–µ—Ä–µ—Ç–∏–Ω –ø–æ 'b'", value="inf", key="miller_intb")
        int_c_str = col3.text_input("–ü–µ—Ä–µ—Ç–∏–Ω –ø–æ 'c'", value="inf", key="miller_intc")
        
        if st.button("–†–æ–∑—Ä–∞—Ö—É–≤–∞—Ç–∏ (hkl)", key="miller_button"):
            try:
                def parse_intercept(s):
                    s_low = s.strip().lower()
                    if s_low == 'inf' or s_low == 'infinity':
                        return np.inf
                    val = float(s)
                    if val == 0: raise ValueError("–ü–µ—Ä–µ—Ç–∏–Ω 0")
                    return val
                
                int_a = parse_intercept(int_a_str)
                int_b = parse_intercept(int_b_str)
                int_c = parse_intercept(int_c_str)

                # 1. –ó–Ω–∞—Ö–æ–¥–∏–º–æ –æ–±–µ—Ä–Ω–µ–Ω—ñ –≤–µ–ª–∏—á–∏–Ω–∏, –æ–±—Ä–æ–±–ª—è—é—á–∏ –Ω–µ—Å–∫—ñ–Ω—á–µ–Ω–Ω—ñ—Å—Ç—å
                inv_a = 0.0 if np.isinf(int_a) else 1.0 / int_a
                inv_b = 0.0 if np.isinf(int_b) else 1.0 / int_b
                inv_c = 0.0 if np.isinf(int_c) else 1.0 / int_c
                
                norm_float = np.array([inv_a, inv_b, inv_c])
                
                # –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –Ω–∞ (0, 0, 0)
                if np.all(norm_float == 0):
                    st.error("–ù–µ–º–æ–∂–ª–∏–≤–æ —Ä–æ–∑—Ä–∞—Ö—É–≤–∞—Ç–∏: —É—Å—ñ –ø–µ—Ä–µ—Ç–∏–Ω–∏ –Ω–µ—Å–∫—ñ–Ω—á–µ–Ω–Ω—ñ (–Ω–µ –≤–∏–∑–Ω–∞—á–∞—é—Ç—å –ø–ª–æ—â–∏–Ω—É).")
                else:
                    # 2. –ó–Ω–∞—Ö–æ–¥–∏–º–æ –Ω–∞–π–º–µ–Ω—à–µ —Å–ø—ñ–ª—å–Ω–µ –∫—Ä–∞—Ç–Ω–µ –¥–ª—è –Ω–æ—Ä–º–∞–ª—ñ–∑–∞—Ü—ñ—ó
                    # –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ —Ñ—É–Ω–∫—Ü—ñ—é –¥–ª—è –∑–Ω–∞—Ö–æ–¥–∂–µ–Ω–Ω—è –º–Ω–æ–∂–Ω–∏–∫–∞, —â–æ–± –∑–≤–µ—Å—Ç–∏ –¥–æ —Ü—ñ–ª–∏—Ö
                    
                    # –í–∏–¥–∞–ª—è—î–º–æ –Ω—É–ª—å–æ–≤—ñ –µ–ª–µ–º–µ–Ω—Ç–∏ –¥–ª—è –∑–Ω–∞—Ö–æ–¥–∂–µ–Ω–Ω—è GCD
                    non_zero_norm = norm_float[norm_float != 0]

                    if len(non_zero_norm) > 0:
                        # –ó–Ω–∞—Ö–æ–¥–∏–º–æ –º–Ω–æ–∂–Ω–∏–∫ –¥–ª—è –ø–µ—Ä–µ–≤–µ–¥–µ–Ω–Ω—è –≤ —Ü—ñ–ª—ñ (–ø—Ä–æ—Å—Ç–∏–π –º–µ—Ç–æ–¥)
                        # –ú–∏ —à—É–∫–∞—î–º–æ –Ω–∞–π–º–µ–Ω—à–µ —á–∏—Å–ª–æ, —è–∫–µ —Ä–æ–±–∏—Ç—å —É—Å—ñ –¥—Ä–æ–±–∏ —Ü—ñ–ª–∏–º–∏
                        
                        # 3. –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ –ø—Ä–æ—Å—Ç–∏–π –º–Ω–æ–∂–Ω–∏–∫ (1/–º—ñ–Ω—ñ–º–∞–ª—å–Ω–∏–π –Ω–µ–Ω—É–ª—å–æ–≤–∏–π –¥—Ä—ñ–±) –¥–ª—è –∑–≤–µ–¥–µ–Ω–Ω—è –¥–æ –Ω–∞–π–º–µ–Ω—à–∏—Ö —Ü—ñ–ª–∏—Ö
                        
                        # –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–∏–π –µ–ª–µ–º–µ–Ω—Ç –¥–ª—è –Ω–æ—Ä–º–∞–ª—ñ–∑–∞—Ü—ñ—ó –¥–æ 1
                        max_abs_norm = np.max(np.abs(non_zero_norm))
                        temp_norm = norm_float / max_abs_norm

                        # –ó–Ω–∞—Ö–æ–¥–∏–º–æ GCD –¥–ª—è –æ–±–µ—Ä–Ω–µ–Ω–∏—Ö —á–∏—Å–µ–ª, —â–æ–± –∑–Ω–∞–π—Ç–∏ –∑–∞–≥–∞–ª—å–Ω–∏–π –º–Ω–æ–∂–Ω–∏–∫
                        multiplier = 1
                        for i in range(1, 100): # –®—É–∫–∞—î–º–æ –¥–æ 100
                            # –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ, —á–∏ —î —á–∏—Å–ª–∞ —Ü—ñ–ª–∏–º–∏
                            if np.all(np.isclose(temp_norm * i, np.round(temp_norm * i))):
                                multiplier = i
                                break
                        
                        h, k, l = np.round(temp_norm * multiplier).astype(int)
                        
                        # –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞, —á–∏ –Ω–µ –æ—Ç—Ä–∏–º–∞–ª–∏ –º–∏ (0, 0, 0) –ø—ñ—Å–ª—è –æ–∫—Ä—É–≥–ª–µ–Ω–Ω—è (–º–∞–ª–æ –π–º–æ–≤—ñ—Ä–Ω–æ, –∞–ª–µ –º–æ–∂–ª–∏–≤–æ)
                        if h == 0 and k == 0 and l == 0:
                            st.error("–ü–æ–º–∏–ª–∫–∞ –Ω–æ—Ä–º–∞–ª—ñ–∑–∞—Ü—ñ—ó. –°–ø—Ä–æ–±—É–π—Ç–µ —ñ–Ω—à–∏–π –≤–≤—ñ–¥.")
                        else:
                            st.success(f"### –Ü–Ω–¥–µ–∫—Å–∏ –ú—ñ–ª–ª–µ—Ä–∞: $({h}, {k}, {l})$")

            except ValueError as e:
                if "–ü–µ—Ä–µ—Ç–∏–Ω 0" in str(e):
                    st.error("–ü–µ—Ä–µ—Ç–∏–Ω –Ω–µ –º–æ–∂–µ –±—É—Ç–∏ 0. –ü–ª–æ—â–∏–Ω–∞ –Ω–µ –º–æ–∂–µ –ø—Ä–æ—Ö–æ–¥–∏—Ç–∏ —á–µ—Ä–µ–∑ –ø–æ—á–∞—Ç–æ–∫ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç.")
                else:
                    st.error(f"–ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω–∏–π –≤–≤—ñ–¥. –í–≤–µ–¥—ñ—Ç—å —á–∏—Å–ª–æ (–Ω–∞–ø—Ä., '1.5') –∞–±–æ 'inf'.")
            except Exception as e:
                st.error(f"–í–∏–Ω–∏–∫–ª–∞ –Ω–µ–≤—ñ–¥–æ–º–∞ –ø–æ–º–∏–ª–∫–∞: {e}")
